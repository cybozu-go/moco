package v1beta1

import (
	"encoding/json"
	"unsafe"

	"github.com/cybozu-go/moco/api/v1beta2"
	"k8s.io/apimachinery/pkg/api/equality"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	apiconversion "k8s.io/apimachinery/pkg/conversion"
	"k8s.io/apimachinery/pkg/runtime"
	"sigs.k8s.io/controller-runtime/pkg/conversion"
)

const (
	SpecPrimaryServiceTemplateAnnotation             = "mysqlcluster.v1beta2.moco.cybozu.com/spec.primaryServiceTemplate"
	SpecReplicaServiceTemplateAnnotation             = "mysqlcluster.v1beta2.moco.cybozu.com/spec.replicaServiceTemplate"
	SpecPodTemplateSpecOverwriteContainersAnnotation = "mysqlcluster.v1beta2.moco.cybozu.com/spec.podTemplate.overwriteContainers"
)

var _ conversion.Convertible = &MySQLCluster{}
var _ conversion.Convertible = &BackupPolicy{}

// ConvertTo converts this MySQLCluster to the Hub version (v1beta2).
func (src *MySQLCluster) ConvertTo(dstRaw conversion.Hub) error {
	dst := dstRaw.(*v1beta2.MySQLCluster)

	return Convert__MySQLCluster_To_v1beta2_MySQLCluster(src, dst, nil)
}

// ConvertFrom converts from the Hub version (v1beta2) to this version.
func (dst *MySQLCluster) ConvertFrom(srcRaw conversion.Hub) error {
	src := srcRaw.(*v1beta2.MySQLCluster)

	return Convert_v1beta2_MySQLCluster_To__MySQLCluster(src, dst, nil)
}

// ConvertTo converts this MySQLCluster to the Hub version (v1beta2).
func (src *BackupPolicy) ConvertTo(dstRaw conversion.Hub) error {
	dst := dstRaw.(*v1beta2.BackupPolicy)

	return Convert__BackupPolicy_To_v1beta2_BackupPolicy(src, dst, nil)
}

// ConvertFrom converts from the Hub version (v1beta2) to this version.
func (dst *BackupPolicy) ConvertFrom(srcRaw conversion.Hub) error {
	src := srcRaw.(*v1beta2.BackupPolicy)

	return Convert_v1beta2_BackupPolicy_To__BackupPolicy(src, dst, nil)
}

// Convert__MySQLCluster_To_v1beta2_MySQLCluster is an autogenerated conversion function.
func Convert__MySQLCluster_To_v1beta2_MySQLCluster(in *MySQLCluster, out *v1beta2.MySQLCluster, s apiconversion.Scope) error {
	if err := autoConvert__MySQLCluster_To_v1beta2_MySQLCluster(in, out, s); err != nil {
		return err
	}

	if err := unmarshalServiceTemplate(in, out); err != nil {
		return err
	}

	if err := unmarshalOverwriteContainers(in, out); err != nil {
		return err
	}

	return nil
}

// Convert_v1beta2_MySQLCluster_To__MySQLCluster is an autogenerated conversion function.
func Convert_v1beta2_MySQLCluster_To__MySQLCluster(in *v1beta2.MySQLCluster, out *MySQLCluster, s apiconversion.Scope) error {
	if err := autoConvert_v1beta2_MySQLCluster_To__MySQLCluster(in, out, s); err != nil {
		return err
	}

	if err := marshalServiceTemplate(&in.Spec, out); err != nil {
		return err
	}

	if err := marshalOverwriteContainers(&in.Spec, out); err != nil {
		return err
	}

	return nil
}

func Convert__MySQLClusterSpec_To_v1beta2_MySQLClusterSpec(in *MySQLClusterSpec, out *v1beta2.MySQLClusterSpec, s apiconversion.Scope) error {
	if err := autoConvert__MySQLClusterSpec_To_v1beta2_MySQLClusterSpec(in, out, s); err != nil {
		return err
	}

	return nil
}

func Convert_v1beta2_MySQLClusterSpec_To__MySQLClusterSpec(in *v1beta2.MySQLClusterSpec, out *MySQLClusterSpec, s apiconversion.Scope) error {
	if err := autoConvert_v1beta2_MySQLClusterSpec_To__MySQLClusterSpec(in, out, s); err != nil {
		return err
	}

	out.ServiceTemplate = (*ServiceTemplate)(unsafe.Pointer(in.PrimaryServiceTemplate))

	return nil
}

// Convert_v1beta2_PodTemplateSpec_To__PodTemplateSpec is an autogenerated conversion function.
func Convert_v1beta2_PodTemplateSpec_To__PodTemplateSpec(in *v1beta2.PodTemplateSpec, out *PodTemplateSpec, s apiconversion.Scope) error {
	return autoConvert_v1beta2_PodTemplateSpec_To__PodTemplateSpec(in, out, s)
}

// marshalServiceTemplate stores the service template as json data in the destination object annotations.
func marshalServiceTemplate(spec *v1beta2.MySQLClusterSpec, dst metav1.Object) error {
	if spec.PrimaryServiceTemplate == nil && spec.ReplicaServiceTemplate == nil {
		return nil
	}

	if equality.Semantic.DeepEqual(spec.PrimaryServiceTemplate, spec.ReplicaServiceTemplate) {
		return nil
	}

	annotations := dst.GetAnnotations()
	if annotations == nil {
		annotations = map[string]string{}
	}

	if spec.PrimaryServiceTemplate != nil {
		u, err := runtime.DefaultUnstructuredConverter.ToUnstructured(spec.PrimaryServiceTemplate)
		if err != nil {
			return err
		}

		data, err := json.Marshal(u)
		if err != nil {
			return err
		}

		annotations[SpecPrimaryServiceTemplateAnnotation] = string(data)
	}

	if spec.ReplicaServiceTemplate != nil {
		u, err := runtime.DefaultUnstructuredConverter.ToUnstructured(spec.ReplicaServiceTemplate)
		if err != nil {
			return err
		}

		data, err := json.Marshal(u)
		if err != nil {
			return err
		}

		annotations[SpecReplicaServiceTemplateAnnotation] = string(data)
	}

	dst.SetAnnotations(annotations)

	return nil
}

// unmarshalServiceTemplate tries to retrieve the data from the annotation and unmarshal it into the service template passed as input.
func unmarshalServiceTemplate(src *MySQLCluster, dst *v1beta2.MySQLCluster) error {
	dstAnnotation := dst.GetAnnotations()

	if hasServiceTemplateAnnotation(src) {
		if primary, ok := src.GetAnnotations()[SpecPrimaryServiceTemplateAnnotation]; ok {
			var s *v1beta2.ServiceTemplate
			if err := json.Unmarshal([]byte(primary), &s); err != nil {
				return err
			}

			dst.Spec.PrimaryServiceTemplate = s
			delete(dstAnnotation, SpecPrimaryServiceTemplateAnnotation)
		}

		if replica, ok := src.GetAnnotations()[SpecReplicaServiceTemplateAnnotation]; ok {
			var s *v1beta2.ServiceTemplate
			if err := json.Unmarshal([]byte(replica), &s); err != nil {
				return err
			}

			dst.Spec.ReplicaServiceTemplate = s
			delete(dstAnnotation, SpecReplicaServiceTemplateAnnotation)
		}
	} else {
		// If the annotation does not exist, copy the same value to primary and replica.
		serviceTemplate := (*v1beta2.ServiceTemplate)(unsafe.Pointer(src.Spec.ServiceTemplate))
		dst.Spec.PrimaryServiceTemplate = serviceTemplate.DeepCopy()
		dst.Spec.ReplicaServiceTemplate = serviceTemplate.DeepCopy()
	}

	if len(dstAnnotation) == 0 {
		dst.SetAnnotations(nil)
	}

	return nil
}

// hasServiceTemplateAnnotation checks if the given object has the service template annotation.
func hasServiceTemplateAnnotation(obj metav1.Object) bool {
	_, primaryFound := obj.GetAnnotations()[SpecPrimaryServiceTemplateAnnotation]
	_, replicaFound := obj.GetAnnotations()[SpecReplicaServiceTemplateAnnotation]

	return primaryFound || replicaFound
}

func marshalOverwriteContainers(spec *v1beta2.MySQLClusterSpec, dst metav1.Object) error {
	if len(spec.PodTemplate.OverwriteContainers) == 0 {
		return nil
	}

	annotations := dst.GetAnnotations()
	if annotations == nil {
		annotations = map[string]string{}
	}

	data, err := json.Marshal(spec.PodTemplate.OverwriteContainers)
	if err != nil {
		return err
	}

	annotations[SpecPodTemplateSpecOverwriteContainersAnnotation] = string(data)

	dst.SetAnnotations(annotations)

	return nil
}

func unmarshalOverwriteContainers(src *MySQLCluster, dst *v1beta2.MySQLCluster) error {
	dstAnnotation := dst.GetAnnotations()

	if containers, ok := src.GetAnnotations()[SpecPodTemplateSpecOverwriteContainersAnnotation]; ok {
		var c []v1beta2.OverwriteContainer
		if err := json.Unmarshal([]byte(containers), &c); err != nil {
			return err
		}

		dst.Spec.PodTemplate.OverwriteContainers = c
		delete(dstAnnotation, SpecPodTemplateSpecOverwriteContainersAnnotation)
	}

	if len(dstAnnotation) == 0 {
		dst.SetAnnotations(nil)
	}

	return nil
}
